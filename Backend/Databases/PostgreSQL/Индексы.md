### 1 уровень

- работа с `EXPLAIN` (`SQL` + `ORM`): `cost`, `rows`, `width`
- общие сведения про индексы (как реализованы, зачем нужны, где хранятся)
- вставка / обновление / удаление записей, расход памяти
- `Index Cond` *vs* `Filter`
- `Index Scan` vs `Seq Scan` vs `Bitmap Scan` + `Bitmap Heap Scan`
- `B-tree` и `HASH`-индексы
- Индексы в `Django` - [ссылка](https://docs.djangoproject.com/en/4.2/ref/contrib/postgres/indexes/)
- Как добавить индексы на старую модель без `downtime` - [ссылка](https://docs.djangoproject.com/en/3.2/ref/contrib/postgres/operations/#concurrent-index-operations)

### EXPLAIN (и EXPLAIN ANALYZE)

`EXPLAIN` - команда, показывающая, как будет выполняться `SQL`-запрос. Она нужна для анализа производительности и помощи в оптимизации запроса. Команда возвращает **план выполнения запроса** - список операций, которые `postgresql` выполнит, чтобы вернуть результат; сам запрос при этом она не выполняет.

#### Синтаксис

```SQL
EXPLAIN SELECT * FROM users WHERE age > 42;
```

#### Результат

```SQL
Seq Scan on users  (cost=0.00..35.50 rows=1000 width=100)
  Filter: (age > 42)
```

`cost=...` - оценка затрат (два числа: стоимость запуска и общая стоимость) до получения всех строк (единица измерения абстрактная)
`rows=...` - предполагаемое количество строк, которые будут возвращены в результате выполнения запроса (основывается на статистике таблиц (`ANALYZE`, `VACUUM ANALYZE`) и фильтрах)
`width=...` - средняя ширина строки в байтах (учитывает только упомянутые в `SELECT` поля)

`EXPLAIN ANALYZE` же дополнительно добавляет фактические результаты выполнения запроса, то есть выведет время выполнения запроса, количество строк, которые были убраны фильтром и т.п.

```SQL
EXPLAIN ANALYZE SELECT * FROM users WHERE age > 42;
```

```SQL
Seq scan on users  (actual time=0.020..0.320 rows=500 loops=1)
	Filter: (age > 42)
	Rows Removed by Filter: 500
Planning Time: 0.100 ms
Execution Time: 0.450 ms
```

Также к команде можно применить дополнительные опции:

- `EXPLAIN (ANALYZE, BUFFERS)` - покажет, сколько данных было считано из кэша / диска
- EXPLAIN (FORMAT JSON) - выведет в формате `JSON`

### Индексы

**Индекс** - это специальная структура данных, позволяющая ускорять поиск строк **по определенному столбцу или столбцам** в базе данных. Аналогия - алфавитный указатель в книгах.

Без индекса `PostgreSQL` ищет данные полным перебором (`Seq Scan`). С индексом же он может прыгнуть сразу туда, где находятся нужные данные (`Index scan`).

#### Синтаксис

```SQL
-- Один столбец
CREATE INDEX ON table (col);

-- Несколько столбцов
CREATE INDEX ON table (col1, col2, ...);
```

Можно также сделать индекс уникальным (не допускающим повторяющиеся значения):

```SQL
CREATE UNIQUE INDEX idx_email ON users(email);
```

По сути это аналог `UNIQUE CONSTRAINT`

Или же частичный индекс:

```SQL
CREATE INDEX idx_active_users ON users(last_login)
WHERE is_active = true;
```


#### Какие индексы поддерживаются PostgreSQL

| Тип индекса                          | Команда создания                           | Поддерживаемые операции                         | Описание                                                                                 | Примеры                                         |
| ------------------------------------ | ------------------------------------------ | ----------------------------------------------- | ---------------------------------------------------------------------------------------- | ----------------------------------------------- |
| **B-tree** (по умолчанию)            | `CREATE INDEX ON table(col);`              | `=`, `>`, `<`, `BETWEEN`, `ORDER BY`, `IS NULL` | Сбалансированное дерево                                                                  | Поиск по числам, датам, строкам                 |
| **Hash**                             | `CREATE INDEX USING Hash ON table(col);`   | `=`                                             | Быстрое `B-tree` на точных сравненияхё                                                   | Поиск по уникальному `token` или по хешу        |
| **GIN** (Generalized Inverted Index) | `CREATE INDEX USING gin ON table(col);`    | `@>`, `<@`, `=`, `?`, `~`, `@@`                 | Подходит для массивов, `JSONB`, полнотекста. Хранит множество значений - множество строк | Поиск в `JSONB` массивах, `tsvector`            |
| **GIST** (Generalized Search Tree)   | `CREATE INDEX USING gist ON table(col);`   |                                                 | Универсальный, поддерживает расстояния, интервалы, гео-данные                            | `PostGIS`, `pg_trgm`, range-типов (`int4range`) |
| **SP-GST** (Space-partitioned GIST)  | `CREATE INDEX USING spgist ON table(col);` |                                                 | Быстрее `GIST` на разреженных данных. Хорош для вложенных диапазонов, текстов            | Префиксный поиск, вложенные диапазоны           |
| **BRIN** (Block Ranged Indexes)      | `CREATE INDEX USING brin ON table(col);`   | `=`, `>`, `<`, `BETWEEN`                        | Минимальный и максимальный диапазон значений на блок. Быстрый, компактный, но грубый (?) | Большие таблицы со временем (`logs`, `metrics`) |
| **btree_gin**                        |                                            |                                                 | Расширение GIN с использованием поведения B-Tree                                         |                                                 |
| **btree_gist**                       |                                            |                                                 | Расширение GIST с использование поведения B-Tree                                         |                                                 |

#### Принцип работы B-Tree индекса (самого популярного)

Принцип работы похож на словарь:

1. Значения сортируются внутри дерева
2. Верхний уровень (корень) указывает, куда двигаться (налево или направо) в зависимости от сравниваемого значения (сравниваются значения индексируемых столбцов)
3. На нижнем уровне (листья) содержатся ссылки на строки таблицы, где лежат реальные данные
4. Поиск осуществляется за логарифмическое время

#### Как индексы хранятся

В базе данных индексы хранятся как файлы внутри каталога базы, причем они обновляются при изменении данных, а также кэшируются в памяти.
Для каждого индексируемого значения `PostgreSQL` хранит
- ключ - само значение (`email = 'test@test.com'`)
- ссылку на строку (**TID**) - указатель на конкретную строку в таблице

#### Индексы и вставка / обновление / удаление записей

`PostgreSQL` использует технологию `MVCC` (Multiversion Concurrency Control), то есть 
- строки **не удаляются и не перезаписываются**, версии сохраняются
- транзакции видят **свою** версию данных
Потому поведение индексов при вставке / изменении / удалении данных не самое очевидное

##### Вставка

- новая строка вставляется в таблицу
- для каждого индекса создается индексная запись (ключ + TID)
- индекс увеличивается в размере

Пример:

```SQL
INSERT INTO users (name, age) VALUES ('Alice', 30);
```

Если индекс по `name` есть, то ('Alice'' + TID) добавится в индекс

В итоге увеличивается размер таблицы и размер индекса (если вставка происходит по индексируемым полям)

##### Обновление 

- postgres не изменяет строку сразу, сначала он помечает ее как "неактуальную", а затем создает новую строку, как при вставке
- далее индексы пересоздают записи

В итоге увеличивается и размер таблицы, и размер индекса

##### Удаление

- postgres не удаляет строку сразу, он сначала помечает ее как "мертвую"
- индексы все еще на нее указывают (пока не будет вызван `vacuum`)

Итого, память все еще будет занята до тех пор, пока не будет запущена чистка мусора

#### Дополнительно

- PostgreSQL не всегда использует индекс., например, если запрос возвращает больше 20-30 процентов строк, используется `Seq scan`, или если индекс не покрывает нужные поля, или же если условие запроса не соответствует типу индекса.


### Index Cond vs Filter

- `Index Cond` - это условие, применяемое на уровне индекса, то есть при поиске в индексе
- `Filter` - это условие, которое применяется уже **после** того, как `PostgreSQL` уже получил строки

В контексте быстродействия, `Index Cond` будет выполняться быстрее. Однако для применения этого условия на выборку должен быть навешен индекс (что логично).

### Index Scan vs Seq scan vs Bitmap Scan + Bitmap Heap Scan

#### Seq scan - последовательное сканирование

Данный тип сканирует всю таблицу построчно, игнорируя индексы. Применяет фильтры к каждой строке.
Используется обычно, если нет подходящего индекса, либо если фильтр выбирает слишком много строк, либо если таблица маленькая, за счет чего индекс использовать невыгодно.
Из минусов - медленное выполнение

#### Index Scan - индексное сканирование

Данный тип сканирует не всю таблицу, а проходится по индексу, благодаря этому сразу находит нужные строки и переходит к ним в таблице (`heap`).
Используется обычно если индекс есть и если он полностью или частично покрывает фильтр. Также может использоваться, если выборка небольшая.
Из преимуществ - выполняется быстро, если возвращает мало строк

#### Bitmap Index Scan + Bitmap Heap Scan - двухфазный способ чтения данных с помощью индексов, когда Index Scan не вывозит

**Bitmap Index Scan**. 
- используется один или несколько индексов, чтобы найти `TID` строк, которые соответствуют условиям
- эти `TID` сохраняются во временной `bitmap`-структуре в памяти
**Bitmap Heap Scan**
- сортирует по блокам собранные на предыдущем шаге `TID`-ы
- группирует доступ к таблице (`heap`)
- читает только нужные страницы, а не каждый раз случайно прыгает к диску

Этот способ чтения данных эффективен тем, что позволяет использовать несколько индексов одновременно, оптимизирует доступ к таблице при умеренном числе строк, а при большом числе совпадений может быть эффективнее, чем `Index Scan`. Из минусов - требует доп. память на битовую карту `TID`-ов, неэффективен при маленькой выборке, а также не поддерживает упорядоченный ввод, так как битмап не хранит сортировку.
